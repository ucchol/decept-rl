from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Optional, Tuple

import numpy as np
import networkx as nx
import gymnasium as gym
from gymnasium import spaces


@dataclass
class EnvConfig:
    n_nodes: int = 12
    horizon: int = 30
    decoy_cost: float = 0.2
    compromise_penalty: float = 1.0
    detect_reward: float = 5.0
    step_alive_reward: float = 0.05  # reward for delaying attacker
    seed: int = 0
    attacker_policy: str = "shortest"  # "shortest" or "random"


class AttackGraphEnv(gym.Env):
    metadata = {"render_modes": ["human"]}

    def __init__(self, config: EnvConfig = EnvConfig()):
        super().__init__()
        self.cfg = config
        self.rng = np.random.default_rng(self.cfg.seed)

        # Action: 0 = noop, 1..N = deploy_decoy(node=action-1)
        self.action_space = spaces.Discrete(self.cfg.n_nodes + 1)

        # Observation: vector of length 4*N + 2
        obs_dim = 4 * self.cfg.n_nodes + 2
        self.observation_space = spaces.Box(
            low=0.0, high=1.0, shape=(obs_dim,), dtype=np.float32
        )

        self.G: nx.Graph = nx.Graph()
        self.goal_node: int = self.cfg.n_nodes - 1
        self.attacker_pos: int = 0
        self.t: int = 0

        self.compromised = np.zeros(self.cfg.n_nodes, dtype=np.int8)
        self.is_decoy = np.zeros(self.cfg.n_nodes, dtype=np.int8)
        self.is_goal = np.zeros(self.cfg.n_nodes, dtype=np.int8)

    def _build_graph(self) -> None:
        n = self.cfg.n_nodes
        G = nx.path_graph(n)

        extra_edges = max(1, n // 2)
        for _ in range(extra_edges):
            a = int(self.rng.integers(0, n))
            b = int(self.rng.integers(0, n))
            if a != b:
                G.add_edge(a, b)

        self.G = G

    def _get_obs(self) -> np.ndarray:
        n = self.cfg.n_nodes
        attacker_onehot = np.zeros(n, dtype=np.float32)
        attacker_onehot[self.attacker_pos] = 1.0

        t_norm = float(self.t) / float(max(1, self.cfg.horizon))
        budget_norm = 1.0 - float(self.is_decoy.sum()) / float(n)

        obs = np.concatenate(
            [
                self.compromised.astype(np.float32),
                self.is_decoy.astype(np.float32),
                self.is_goal.astype(np.float32),
                attacker_onehot,
                np.array([t_norm, budget_norm], dtype=np.float32),
            ]
        )
        return obs.astype(np.float32)

    def reset(
        self, *, seed: Optional[int] = None, options: Optional[Dict[str, Any]] = None
    ) -> Tuple[np.ndarray, Dict[str, Any]]:
        if seed is not None:
            self.rng = np.random.default_rng(seed)

        # allow per-episode override
        if options and "attacker_policy" in options:
            self.cfg.attacker_policy = str(options["attacker_policy"])

        self._build_graph()

        self.goal_node = self.cfg.n_nodes - 1
        self.attacker_pos = 0
        self.t = 0

        self.compromised[:] = 0
        self.is_decoy[:] = 0
        self.is_goal[:] = 0
        self.is_goal[self.goal_node] = 1

        self.compromised[self.attacker_pos] = 1

        info: Dict[str, Any] = {"goal_node": self.goal_node, "attacker_policy": self.cfg.attacker_policy}
        return self._get_obs(), info

    def _deploy_decoy(self, node: int) -> float:
        if node < 0 or node >= self.cfg.n_nodes:
            return 0.0
        if self.is_goal[node] == 1:
            return 0.0
        if self.is_decoy[node] == 1:
            return 0.0
        self.is_decoy[node] = 1
        return -self.cfg.decoy_cost

    def _attacker_move_shortest(self) -> int:
        try:
            path = nx.shortest_path(self.G, self.attacker_pos, self.goal_node)
            if len(path) >= 2:
                return int(path[1])
        except nx.NetworkXNoPath:
            pass

        nbrs = list(self.G.neighbors(self.attacker_pos))
        if not nbrs:
            return self.attacker_pos
        return int(self.rng.choice(nbrs))

    def _attacker_move_random(self) -> int:
        nbrs = list(self.G.neighbors(self.attacker_pos))
        if not nbrs:
            return self.attacker_pos
        return int(self.rng.choice(nbrs))
    def _attacker_move_stealthy(self) -> int:
        """
        Moves toward goal but prefers to avoid decoy nodes.
        Minimizes: dist_to_goal(next) + alpha * is_decoy(next)
        """
        alpha = 10.0  # higher => more decoy-avoidant
        nbrs = list(self.G.neighbors(self.attacker_pos))
        if not nbrs:
            return self.attacker_pos

        best = None
        best_score = float("inf")
        for n in nbrs:
            try:
                d = nx.shortest_path_length(self.G, n, self.goal_node)
            except nx.NetworkXNoPath:
                d = 10**9
            score = float(d) + alpha * float(self.is_decoy[n])
            if score < best_score:
                best_score = score
                best = n
        return int(best if best is not None else self.attacker_pos)
    def step(self, action: int):
        assert self.action_space.contains(action)

        terminated = False
        truncated = False
        info: Dict[str, Any] = {}

        reward = 0.0
        if action != 0:
            node = action - 1
            reward += self._deploy_decoy(node)

        # attacker move
        if self.cfg.attacker_policy == "random":
            next_pos = self._attacker_move_random()
        elif self.cfg.attacker_policy == "stealthy":
            next_pos = self._attacker_move_stealthy()
        else:
            next_pos = self._attacker_move_shortest()
        self.attacker_pos = next_pos
        self.compromised[self.attacker_pos] = 1

        reward += self.cfg.step_alive_reward

        if self.is_decoy[self.attacker_pos] == 1:
            reward += self.cfg.detect_reward
            terminated = True
            info["event"] = "detected_on_decoy"
        elif self.attacker_pos == self.goal_node:
            reward -= self.cfg.compromise_penalty
            terminated = True
            info["event"] = "goal_reached"

        self.t += 1
        if self.t >= self.cfg.horizon:
            truncated = True
            info["event"] = "horizon"

        obs = self._get_obs()
        return obs, float(reward), terminated, truncated, info

    def render(self):
        print(
            f"t={self.t} attacker={self.attacker_pos} goal={self.goal_node} "
            f"decoys={int(self.is_decoy.sum())} compromised={int(self.compromised.sum())} "
            f"attacker_policy={self.cfg.attacker_policy}"
        )




